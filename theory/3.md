## Контекст this
Обычное использоваиние контекста, когда функция привязана к объекту и мы хотим обратиться к полям объекта из функции.

Так, у функции есть свой контекст - **функциональный контекст**. В этот контекст попадают все идентификаторы, которые передаются в качестве аргументов и все идентификаторы, которые объявлены внутри функции.

Также у функции есть **объектный контекст**. К объектному контексту можно обращаться через поле ***this***. **У lambda функций (стрелочых) нет объектного контекста**

Пример:
```javascript
'use strict';

const Context = function() {
    this.name = 'Not Kiev';
    const city = {
        name: 'Kiev',
        year: 482,
        // Возмет контекст из объекта
        f1: function() {
            return this.name;
        },
        // Возмет контектс из основной функции
        f2: () => {
            return this.name;
        },
        // Имеет имя и ключ возмет контекст из объекта
        f3() {
            return this.name;
        }
    };
    return city;
};

const city = new Context();

console.log('city.f1() = ' + city.f1()); //city.f1() = Kiev
console.log('city.f2() = ' + city.f2()); //city.f2() = Not Kiev
console.log('city.f3() = ' + city.f3()); //city.f2() = Kiev
```
[Пример кода](practice/3/1_example.js)
## Immediately-invoked function expression IIFE
Функция объявляется, сразу вызываем и сразу забываем на нее ссылку. Это было необходимо раньше, когда нельзя было создавать контексты при помощи нового синтаксиса {}, но можно было в качестве экранирования от наружного контекста использовать такую запись

```javascript
'use strict';

// Старый синтаксис
(function f1(){
    console.log('f1');
})();

(function (){
    console.log('anonymus');
})();

(() => {
    console.log('lambda');
})();

// Современный синтаксис
{
    console.log('block');
}
```
[Пример кода](practice/3/2_example.js)

Сейчас предпосчтительно использвать современный синтаксис.
## Методы call & apply
Метод **call()** вызывает функцию с указанным значением **this** и индивидуально предоставленными аргументами. 
```fun.call(thisArg[, arg1[, arg2[, ...]]])```
Метод apply() вызывает функцию с указанным значением this и аргументами, предоставленными в виде массива (либо массивоподобного объекта)
```fun.apply(thisArg, [argsArray])```
Пример:
```javascript
'use strict';

function f1(a, b) {
    console.log('f1(' + a + ', ' + b + ')');
}

f1(2, 3);
// Все что может быть передано вместо null (объект) привяжет контектс к этой функции
// Все поля этого объекта будут доступны в функции через this
f1.call(null, 2, 3);

const arr = [2, 3];
// ... при вызове функции - спред оператор, разбивает массив на элементы и делает их аргументами функции 
f1(...arr);// f1(2, 3)
// Тоже самое делает и apply только вторым параметром принимает массив
f1.apply(null, arr); //f1(2, 3)
```
[Пример кода](practice/3/3_example.js)
## Замыкания
Рассмотрим пример:
```javascript
'use strict';

// Пример замыкания
const hash = () => {
    const data = {};
    const counter = 0;
    return (key, value) => {
        data[key] = value;
        // counter = counter + 1;
        console.dir({ counter });
        return data;
    };
};

const h1 = hash(); // здесь мы получили функцию лямбду, которая вернулась через return ф-ии hash
h1('name', 'Marcus'); // h1 работает так, как будто лежит внутри ф-ии hash и видит при этом data & counter
h1('city', 'Rome');
const obj1 = h1('year', 121);
// obj1 - это получается ссылка на объект data, который возвращается из вложенной лямбды

console.dir({ obj1 }); //{ obj1: { name: 'Marcus', city: 'Rome', year: 121 } }
```
[Пример кода](practice/3/4_example.js)

Функция hash имеет имеет два интедентификатора data & counter и возвращает лямбду. Лямбда видит идентификаторы функции hash и может изменять их.

Присвоим функцию hash в константу h1. Вызывая фунцию h1 с параметрами, мы как бы вызываем функцию hash и меняем ей идентификаторы. Поэтому лямбда замнкута на контекст функции hash
## Способ вызова функции - чейнинг - chain
При помощи замыкания мы можем реализовать такой способ вызова функции как **chain**
Пример:
```javascript
'use strict';

const hash = () => {
    const data = {};
    // 1 параметер объект у которого нужно создать поле 2 пар. название свойства
    Object.defineProperty(data, 'add', {
        // это поле не будет перечисляться при помощи цикла for
        // это свойство не видно при выводе 
        enumerable: false,
        // Значение, которое равно этой функции, т.е на свойстро add навешивается функция
        value(key, value) {
            // Записываем значение по ключу
            data[key] = value;
            // возвращаем data
            return data;
        }
    });
    return data;
};

console.dir(
        hash()
            .add('name', 'Marcus')
            .add('city', 'Rome')
            .add('born', 121)
);
// output : { name: 'Marcus', city: 'Rome', born: 121 }
```
[Пример кода](practice/3/5_example.js)

Метод **Object.defineProperty()** определяет новое или изменяет существующее свойство непосредственно на объекте, возвращая этот объект.

## Сумматор на базе замыкания
Пример кода:
```javascript
'use strict';

// Сумматор на основе двух вложенных лямбд
// x отображается в y, а y имеет выражение
const add = x => y => {
    const z = x + y;
    console.log(x + '+' + y + '=' + z);
    return z;
}
// Самая простая форма записи этой функции
//const add = x => y => x + y

// Вызов такой функции. В add передаем 3, он попадает в x, результатом которой есть функция, 
// поэтому передаем еще аргумент y, котороый уже попадает в аргументом в функцию y
const res = add(2)(3);
console.log(res);
```
Это тоже цепочный вызов, но в данном случае x попадает в замыкание и храниться в нем. Дальше мы из замыкания получаем функцию с аргументом y. Он складывается с x, который храниться в замыкании, а на наружу выдается результат.
[Пример кода](practice/3/6_example.js)