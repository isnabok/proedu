## Контекст this
Обычное использоваиние контекста, когда функция привязана к объекту и мы хотим обратиться к полям объекта из функции.

Так, у функции есть свой контекст - **функциональный контекст**. В этот контекст попадают все идентификаторы, которые передаются в качестве аргументов и все идентификаторы, которые объявлены внутри функции.

Также у функции есть **объектный контекст**. К объектному контексту можно обращаться через поле ***this***. **У lambda функций (стрелочых) нет объектного контекста**

Пример:
```javascript
'use strict';

const Context = function() {
    this.name = 'Not Kiev';
    const city = {
        name: 'Kiev',
        year: 482,
        // Возмет контекст из объекта
        f1: function() {
            return this.name;
        },
        // Возмет контектс из основной функции
        f2: () => {
            return this.name;
        },
        // Имеет имя и ключ возмет контекст из объекта
        f3() {
            return this.name;
        }
    };
    return city;
};

const city = new Context();

console.log('city.f1() = ' + city.f1()); //city.f1() = Kiev
console.log('city.f2() = ' + city.f2()); //city.f2() = Not Kiev
console.log('city.f3() = ' + city.f3()); //city.f2() = Kiev
```
## Immediately-invoked function expression IIFE
Функция объявляется, сразу вызываем и сразу забываем на нее ссылку. Это было необходимо раньше, когда нельзя было создавать контексты при помощи нового синтаксиса {}, но можно было в качестве экранирования от наружного контекста использовать такую запись

```javascript
'use strict';

// Старый синтаксис
(function f1(){
    console.log('f1');
})();

(function (){
    console.log('anonymus');
})();

(() => {
    console.log('lambda');
})();

// Современный синтаксис
{
    console.log('block');
}
```
Сейчас предпосчтительно использвать современный синтаксис.
## Методы call & apply
Метод **call()** вызывает функцию с указанным значением **this** и индивидуально предоставленными аргументами. 
```fun.call(thisArg[, arg1[, arg2[, ...]]])```
Метод apply() вызывает функцию с указанным значением this и аргументами, предоставленными в виде массива (либо массивоподобного объекта)
```fun.apply(thisArg, [argsArray])```
Пример:
```javascript
'use strict';

function f1(a, b) {
    console.log('f1(' + a + ', ' + b + ')');
}

f1(2, 3);
// Все что может быть передано вместо null (объект) привяжет контектс к этой функции
// Все поля этого объекта будут доступны в функции через this
f1.call(null, 2, 3);

const arr = [2, 3];
// ... при вызове функции - спред оператор, разбивает массив на элементы и делает их аргументами функции 
f1(...arr);// f1(2, 3)
// Тоже самое делает и apply только вторым параметром принимает массив
f1.apply(null, arr); //f1(2, 3)
```
## Замыкания
Рассмотрим пример:
```javascript
'use strict';

// Пример замыкания
const hash = () => {
    const data = {};
    const counter = 0;
    return (key, value) => {
        data[key] = value;
        // counter = counter + 1;
        console.dir({ counter });
        return data;
    };
};

const h1 = hash(); // здесь мы получили функцию лямбду, которая вернулась через return ф-ии hash
h1('name', 'Marcus'); // h1 работает так, как будто лежит внутри ф-ии hash и видит при этом data & counter
h1('city', 'Rome');
const obj1 = h1('year', 121);
// obj1 - это получается ссылка на объект data, который возвращается из вложенной лямбды

console.dir({ obj1 }); //{ obj1: { name: 'Marcus', city: 'Rome', year: 121 } }
```
Функция hash имеет имеет два интедентификатора data & counter и возвращает лямбду. Лямбда видит идентификаторы функции hash и может изменять их.

Присвоим функцию hash в константу h1. Вызывая фунцию h1 с параметрами, мы как бы вызываем функцию hash и меняем ей идентификаторы. Поэтому лямбда замнкута на контекст функции hash