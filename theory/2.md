# Функции, лямбды (стрелочные функции), контексты, замыкания в JavaScript

## Понятие функции
**В математике** - дискретные и неприрывные. Основная задача Ф. - преобразование и\или отображение величин.

**В программировании** (в основном) это понимание Ф. через алгоритм. Т.е последовательность действий по преобразованию параметров.

Функции могут быть чистыми и с побочными эффектами. Чистые всегда дают предсказуемый результат. Пример Ф. sin(), sort() - (получает число и ответ будет ожидаемое постоянное число)

Побочные эффекты появляются вследствии того что Ф. лежит в каком-то контексте, как минимум в глобальном контексте и в контексте файла в котором она находится (для JS) Благодаря этому функции видят идентификаторы (назв. переменных, констант) в этих контекстах и могут их менять (с побочными эффектами, не чистая ф-я).

Определения функций в [Dictionary](dictionary.md).

### Способы определения функции
* **Function declaration**
```javascript
function inc(a) {
    return a + 1; // inc(1) = 2
}
```
Ничего никуда не прсваивается, есть ключевое слово function, дальше блок операторов, return. Если return нет, то Ф. вернет undefined. По факту, если функция ничего не возвращает, то это не чистая функция, поскольку она скорее всего меняет состояние. **Function declaration** будет виден во всех частях файла в котором есть такое объявление.

* **Function expression**
```javascript
const sum = function(a, b) {
    return a + b; // sum(2, 3) = 5
}
```
**Function expression** - будет виден только после того, как он был присвоен в переменную. Это значение функционального типа присвоенное идентификатору sum. Может сложить 2 числа или 2 строки. Оптимизирущий компилятор JS разделит ее на две типизированные функции для работы с числами и строками. Это называется обобщенное программирование или дженерики.

* **Функция-стрелка / Lambda expression, Arrow function**
```javascript
const max = (a, b) => (a > b ? a : b); // max(2, 5) = 5
```
Есть идентификатор, входные параметры, стралка и expression справа, который возвряшается как return Ф. В данном случае тернарный оператор. 
* **Лямбда-функция / Lambda function**
```javascript
const avg = (a, b) => {
    const s = sum(a, b);
    return s / 2; // avg(2, 4) = 3
}
```
## Области видимости
Функции и не только создают области видимости. 
Пример кода:

```javascript
'use strict';

const cities = ['Kiev', 'Roma', 'London', 'Riga', 'Baku'];
// f(s) - lambda expression - отображает длинну строки переданной в нее (s)
const f = s => s.length;

/*
* Function declaration
* cities & f из внешнего блока будут перекрыты внутренним объявлением
* .map - метод массива для перебора каждого элемента массива.
*/  
function f1() {
    const cities =  ['Kiev', 'Baku'];
    const f = s => s.toUpperCase();
    console.dir({ cities });
    console.dir(cities.map(f));

    //блок операторов, который закроет (переопределит) вешний идентиф. f ф-и f1
    {
        const f = s => s.toLowerCase();
        console.dir({ cities });
        console.dir(cities.map(f));
    }
    // блок операторов переопределит cities, а f возьмет из f1 (toUpperCase)
    {
        const cities = ['Roma', 'London', 'Riga'];
        console.dir({ cities });
        console.dir(cities.map(f));
    }
}

f1();

conole.dir({ cities });
// f будет взята из начала файла, из общего скоупа
console.dir(cities.map(f));
```
Идентификатор можно передать в другую ф-ю и он будет виден из нее, а можно замкнуть и он из функции будет виден внешне.